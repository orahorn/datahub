# 01. Интерфейсы Информационно-Управляющих Систем

Простейший электронный интерфейс - это выключатель и лампочка - передаёт сигнал в один бит на ввод/вывод.
Также и объём усвоенной информации хранится в ондом триггере (механическом).
Но если сделать кнопку - то триггер может быть электронным.

Более сложный интерфейс - посимвольный, где символ - ограниченная небольшим количеством (как правило 8) бит
последовательность. Она может для удобства передачи обрамляться стратовым или стоповым битом.

Также важна просстранственно-временная дисциплина передачи сигналов (кодирование) на интерфейсы:
последовательная , параллельная /смешанная.

Первым простейшим способом усваивать информацию была азбука/код Морзе, телеграм, где электрические сигналы передавались
последовательно и имели разную длительность (точки-короткие ,тире-длинные).

Сигналы могут быть не только цифровыми / дискретными, но и аналоговыми - например они могут задавать плавную позицию, или считывать
её , например с манипулятора джойстик.

Всё это было больше аппаратными интерфейсами, о них ещё будет далее.
Но в наши дни появились программные интерфейсы различных классов и видов.
Далее про пользовательские интерфейсы: между компьютером и человеком.

## 01.01. CLI

После появления устройств хранения данных (памяти) с адресацией и произвольной выборкой стали
появляться интерфейсы принимающие символы (телетайпы) группами , названными привычно из книг - строками.
Также построчные устройства вывода : ленты, перфокарты. Впоследствии мониторы, демонстрирующие ограниченное количество строк.

### Интерактивные командные оболочки

С появлением полноценных терминалов с монитором и клавиатурой стало возможно работать на уровне и управляющих символов.
Самым необходимыми такими символами были перевод строки (LF-Line Feed) и возврат каретки (CR - Carridge Return).
Оба символа появились в Microsoft DOS и перекочевали в Windows в качестве конца (разграничителя) строк.
В мире Unix - для обозначения завершения строки в файлах использовался на клавиатуре CR, а в файлах и на мониторах LF.
После редактирования строки и подтверждения готовности нажатием Enter - она целиком передаётся на разбор и интерпретацию оболочке.

Первым интерпретатором был Borne Shell, потом C-Shell.
В наши дни доступна, в рамках пакета ПО tcsh (Tenex Shell).
Потом Korn Shell (ksh), объединившим свойства обоих. Ksh популярен в BSD-системах.
Возник стандарт POSIX (Portable Operating Systmems Interface).
И, наконец, оболочка Bash - по-умолчанию в Linux , и некогда macOS.
С некоторых времён macOS перевели на навороченную оболочку zsh.


### Построчные текстовые редакторы

Первый редактор на уровне работы с одной строкой был Edlin в DOS
В Unix - ed, ex.

Потоковый (неинтерактивный) редактор sed
- фактически программный фильтр  - интерфейс между вводом/выводом процессов (Машина <-> машина).
Относится к другому классу ПО, хотя и похож

### Библиотека ReadLine

Позволяет работать с буфером символов, историей команд, которые сохраняются в файлах .
Их могут использовать совершенно разные приложения (не только CLI).

## 01.02. TUI

Текстовый пользовательский интерфейс (Text User Interface) отличается от CLI, тем, что программа управляет с его помощью
всем экраном (совокупность строк), а не отдельной строкой.
Доступны функции установки курсора в произвольную строку, скроллинг строк в разные направления, изменение аттрибутов 
символов в произвольно заданных строках.
Появляется понятие псевдографики - окна с обрамляющими символами, выпадающие меню с симуляцией теней, линейки прокрутки,
...
Основное преимущество перед графикой - малый объём трафика, а значит и уменьшение задержек на малоскоростных линиях
связи (спутник, напрмер).




### Полноэкранные многострочные редакторы vi(m) , emacs

Первый многострочный интерактивный редактор в Unix - vi (visual).
В наши дни остаётся весьма популярным в виде ViM, но есть ещё другие клоны (например, neovim).
Имеет скриптовую расширяемость. Также доступна графическая надстройка gvim (про GUI см. далее).

Emacs - использует библиотеку readline. Изначально каждое нажатие клавиш спец. комбинаций, порождало выполнение макрокоманд
на языке lisp.


### Файловые оболочки

Различные наследники двухпанельных менеджеров (прародитель Norton Commander):

* Midnight Commander (mc)
* Demos Commander (DeCo)
* FAR Manager


### Библиотеки Curses, S-Lang

Для работы в TUI используют различные эмуляторы терминалов, например xterm в Linux или приложение Terminal в macOS.
Они должны реализовывать стандарты терминалов , которые указываются в переменной среды `$TERM`: самый известный VT-100, потом ANSI, ну и те же xterm, linux.

Среди способов управления терминалами - вывод escape последовательностей, меняющих положение курсора на экране.
Для программирования есть базовые средства, например в Си - заголовочный файл `termios.h` 
из стандартной библиотеки для управления режимами вывода
на терминал (телетайп некогда).

Потом, отдельная библиотека ncursesw 5-й версии - современная библиотека для работы в TUI с учётом последних особенностей Unicode.
Также библиотека curses входит в базовую поставку последнего Pyhton (3-й версии).

В качестве альтернативы есть класс приложений (например, панельный файловый менеджер Midnight Commander) которые используют
библиотеку S-Lang второй версии (тоже умеет Unicode-символы).
Там есть функции, начинающиеся с `SLsmg_*` (от англ. "Screen Management").

### Указательное устройство и библиотека gpm

Даже без запуска графической оконной системы UNIX под названием X11 в 
обычной текстовой консоли можно работать с мышью с помощью сервиса gpm (Generic Purpose Mouse).
Можно выделять и копировать текст. А также пермещать, например, в файловом менеджере mc
курсор между панелями, выделять меню и т.д.

### Псевдографика и ASCII-art

Позволяет используя комбинации символов в виде рамок, крестиков, заливок, линий, разных уголков
создавать такие элементы, как:

* рамки окон 
* тени от окон
* разветвлённые выпадающие меню
* диалоги с кнопками
* линейки прокрутки контента

Первым успешным применением были приложения Microsoft в DOS, библиотека Turbo Vision
от компании Borland реализованная в языках Pascal и C++.

Аналогичная библиотека поддерживается во Free Pascal Compiler (FPC).

## 01.03 GUI

После того, как появились электронно-лучевые трубки и вычислительная
техника всё массовей начала проникать в технологический быт  была
разработана методология отображения информации в виде матрицы точек.
Эти точки придумали называть пикселями.
Сначала они были как биты - двухцветные: чёрно-белые или тёмно-зелёные.
После, пиксели стали кодировать цветами из трёх компонент: RGB.
Помимо шрифтов, стали отображать полноценные графические элементы,
геометрические фигуры, фотографии, трёхмерные модели...
Подобная графика в виде матрицы разноцветных пикселей называется растровой.


Позже появилась векторная графика, когда данные изображения стали описывать в
ограниченных координатах (начало-конец, либо начало-угол-длина, начало-радиус...).
Векторных мониторов мне пока неизвестно, но графические адаптеры
умеют с подобными данными работать (ускорять вывод на растровый монитор).

Самыми популярными библиотеками которые умеют задействовать ускорение являются:

* 2D:
	- Cairo
	- libxml
* 3D:
	- OpenGL
	- Vulkan

В целом интерфейс получил назвыние GUI (Graphical User Interface) или
русский аналог графический пользовательский интерфейс (ГПИ).

Первые опыты с графическими компьютерными изображениями и соответсвующим
пользовательским интерфейсом проводила компания Xerox на компьютере модели Alto
в лаборатории PARC в 1973 году.

Сегодня графические интерфейсы пользователя разрабатывают люди с профессией
FrontEnd-программист.

### Откытая подсистема X-Window


Также в быту был популярен дешёвый компьютер Comodore фирмы Amiga, примерно в то же время

Параллельно продажам Apple (см. далее) в июне 1984 года вышла графическая подсистема X-Window
для семейства ОС UNIX, разработанная в M.I.T.
Она существует в практически неизменным виде и до наших дней под именем X11.




### Графическая система Aqua

В 1984 году уже на рынке появился компьютер Apple Macintosh. 
Компьютер Агат разработан в НИИВК по образу компьютера Apple-II.
В нём есть BASIC с операторами для отрисовки геометрических фигур.

### Подсистема Win32 для ОС Microsft

Годом позже Macintosh 
появилась известнейшая в нашей стране Windows 1.0 компании Microsoft.
Это была сначала оболочка к ОС DOS, но в настоящее время
API Win32 практически не отделима от графического ядра.


### Особенности графических кроссплатформенных приложений

В учебниках по программированию на C++ Страуструп и Столяров приводят
техники работы с FLTK и созданию на её базе своих универсальных классов
графическим пользовательским интерфейсом.
Их особенностью является использование объектно-ориентированной парадигмы для кодирования
графических элементов пользовательского интерфейса (виджетов) с помощью
минимально возможного переносимого между платформами абстрагирования...
Типы виджетов:

* элементы меню
* иконки
* кнопки
* ползунки
* поля для ввода данных с клавиатуры и их редактирования
* объекты для растровой отрисовки изображений, интегрируемые с библиотеками:
	- Cairo
	- OpenGL
	- изображений файлов:
		+ PNG
		+ JPG

Список интегрируемых подключаемых библиотек можно посмотреть командой:

	fltk-config --help

Их необходимо добавлять при компиляции программы, например, командой:

	fltk-config --compile файл.cxx

Библиотека жива и эволюционирует, не смотря на то, что она остаётся простой 
и не пытается задействовать весь арсенал последних стандартов C++ (шаблоны, перегрузки , ...)
Типичное приложение с библиотекой FLTK по сути пишется на классических вызовах C, используя только
графические классы библиотеки как таковой, либо свой код с наследованием от её классов.

Первые версии библиотеки давали универсальный внешний вид приложениям, отрисовывая растр ...
Это немного конфузило пользователей, привыкших к однообразию отображения виджетов.
Сейчас идёт тенденция на замену этого кода на вызовы функций графики из конкретной ОС:

* macOS (Aqua)
* X-Window (вплоть до версии 1.3), Wayland (с 1.4 версии Linux) : <https://www.fltk.org/str.php?L3371>
* Win32 API

Пример: класс открытия файлов [Fl_Native_File_Chooser](https://www.fltk.org/doc-1.3/classFl__Native__File__Chooser.html).

Другие промышленные библиотеки кроссплатформенной разработки ГПИ:

* Qt - самая востребованная на госпредприятиях библиотека в России и ряде стран Северной Европе
* wxWidgets - библиотека C++ с использованием классических макросов Си. Имеет ряд привязок
* tk - библиотека придуманная в языке TCL, но ставшая базовой комплектной даже для Python3.
* gtk - чисто Сишная библиотека используется, как базовая для остальных
* Enlightenment Foundation Libraries (EFL) - 
* SFML - популярная современная библиотека в индустрии разработки игр
* JUCE - C++ библиотека
* старые библиотеки для игр и мультимедия:
	- SDL 
	- Allegro

На других языках программирования реализован свой GUI.
Например Java использует универсальное API для создания форм.

## 01.04. Аппаратные интерфейсы машина-машина

Для передачи управляющих воздействий между подсистемами, где в цепочку управления не включён человек,
тоже используют стандарты на различные электрические, геометрические и временны́е  характеристики.

Самые известные межкомпьютерные интерфейсы относятся к проводному Ethernet'у, скорость которого достигает
в промышленных применениях 10G. Самый распространённый 1G.
В бытовых условиях успешно эксплуатируется и классический 100Mbit (Fast) Ethernet.

В наши дни сигнальные интерфейсы реализуют шины GPIO (General Purpose Input/Output), вмонтированные, например, в микрокомпьютеры
Raspberry Pi и контролеры семейтва Arduino. Они принимают и передают сигналы в виде уровня напряжений около 3 вольт.

 Интерфейс GPIO на контроллерах оформлен в виде обычной
гребёнки проводов, но позволяет передавать самый разнообразный набор сигналов: от электропитания и аналоговых,
до относительно быстрых цифровых. Через GPIO подключают и кнопки, и светодиоды, разные индикаторы и целые ЖК 
сенсорные экраны и т.д.


Для них существуют среды программирования на обычном стационарном ПК на современных
популярных языках : JavaScript, Python, C++ и т.д. ...

Есть также промышленные применения GPIO.
В автопромышленности и станках ЧПУ сегодня используется интерфейс [CAN](https://ru.wikipedia.org/wiki/Controller_Area_Network).

Из аппаратных интерфейсов:

* Последовательные разъёмы - RS-232, RS-465
* Шины [PCI](https://ru.wikipedia.org/wiki/PCI) и [Compact-PCI](https://ru.wikipedia.org/wiki/CompactPCI)



## 01.05. Межпрограммные интерфейсы

Межпрограммные интерфейсы, определяют спецификации между использованием одного программного обеспечения другим.
Т.н. вызовы процедур, фукнкций, собранные в единую систему могут определять конкретный стандарт программного
интерфейса.

### Интерфейс прикладного программирования API

Другое название [программный интерфейс приложения](https://ru.wikipedia.org/wiki/API) т.е. всегда прикладное программное
обеспечение использует API в процессе своего выполнения.
Чаще всего приложение пользуется вызовами набором функций, которые собраны вместе в какую-то
[тематическую библиотеку](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)).
Например, для отрисовки изображений в графическом режиме работы монитора в системах UNIX используют X-Window API.
Для того же самого эффекта приложения Windows используют интерфейс Win32 API.
В мультимедия приложениях и играх используется т.н. интерфейс работы с графическими устройствами
- [GDI](https://ru.wikipedia.org/wiki/GDI).

Подавляющее большинство приложений в современных ОС используют в той или иной степени библиотеку C,
т.к. её API неизменен при переносе исходного кода в другие системы.

Также есть API для работы со звуком, например [OpenAL](https://ru.wikipedia.org/wiki/OpenAL), который создаёт
разные пространственные звуковые эффекты.

Все названные интерфейсы специфицируют сигнатуры функций (параметры и возвр. значения) на уровне исходного кода.
Но после компиляции программы в исполняемый двоичный формат, действуют правила, описанные в т.н.
[двоичном интерфейсе приложений](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9), 
который определяет, какие регистры процессора, стековая и другая память готовится перед вызовом библиотечной функции в ОС.

Для виртуальных машин (например Java или .Net) тоже есть свои инерфейсы, которые при неизменности между ОС
обеспечивают ту самую заявленную кроссплатформенность [Write Once, run enywhere](https://en.wikipedia.org/wiki/Write_once,_run_anywhere) .

### Интерфейс вызова функций ядра

Для того, чтобы приложение или библиотечная функция попросила что-то выплонлить ядро, используется
набор вызовов системы или на англ. System Calls [Syscalls](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2). Как правило, системные вызовы различаются между семействами ОС, в отличае от 
того, что программистам предлагают стандартные библиотеки. Но их используют для написания этих самых библиотек, для ускорения в 
отдельных случаях работы приложений. Даже схема вызова системы на уровне инструкций ассемблера отличаются между видами
Unix систем: Linux и BSD. Но как правило, последняя иснтрукция вызывает прерывание, переводящее процессор из
[режима пользователя](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE)
в [режим ядра](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B6%D0%B8%D0%BC_%D1%8F%D0%B4%D1%80%D0%B0).
После чего происходит возврат с передачаей от ядра неких параметров (как правило одного кода завершения).


### Прочие программные подсистемные интерфейсы

Интерфейс взаимодействия компьютера с сетью.
Самый распространённый: [Berkley Socket API](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82%D1%8B_%D0%91%D0%B5%D1%80%D0%BA%D0%BB%D0%B8). Оформлен в виде библиотеки внутри стандартной Си. Содержит функции открытия соединения, обмена сообщениями, закрытия дескрипторов соединений с другими компьютерами по сети TCP/IP.

В системах HPE NonStop используется Subsystem Programmatic Interface (SPI),
который определяет набор сообщений между подсистемами в их распределённой среде: туда входят форматы не только
сообщений , но и форматы ответов.
Также форматы токенов передающихся в сообщениях.
Что также определяет форматы сообщений об ошибках.


## Источники

* [Азбука Морзе](https://ru.wikipedia.org/wiki/Азбука_Морзе)
* [GPIO](https://ru.wikipedia.org/wiki/GPIO)
* [CLI](://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%BE%D0%B9_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8)
* [TUI](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
* [ed](https://ru.wikipedia.org/wiki/Ed)
* [ex](https://ru.wikipedia.org/wiki/Ex_%28Unix%29)
* [POSIX](https://ru.wikipedia.org/wiki/POSIX)
* [ViM](https://ru.wikipedia.org/wiki/Vim)
* [Emacs](https://ru.wikipedia.org/wiki/Emacs)
* [GUI](https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
* [Псевдографика](https://ru.wikipedia.org/wiki/%D0%9F%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0)
* [Xerox Alto](https://ru.wikipedia.org/wiki/Xerox_Alto) - первый компьютер с графическим интерфейсом
* [Xerox PARC](https://ru.wikipedia.org/wiki/Xerox_PARC) - научно-исследовательский центр компании Xerox
* [Macintosh](https://ru.wikipedia.org/wiki/Macintosh)
* [управление экраном на Си в библиотеке S-Lang](https://www.jedsoft.org/slang/doc/html/cslang-8.html)
* [Человеко-машинный интерфейс](https://ru.wikipedia.org/wiki/%D0%A7%D0%B5%D0%BB%D0%BE%D0%B2%D0%B5%D0%BA%D0%BE-%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
* [Эргономика](https://ru.wikipedia.org/wiki/%D0%AD%D1%80%D0%B3%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0)
* [Юзабилити](https://ru.wikipedia.org/wiki/%D0%AE%D0%B7%D0%B0%D0%B1%D0%B8%D0%BB%D0%B8%D1%82%D0%B8)
* [Интерфейс пользователя](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
* Графический интерфейс [WIMP](https://ru.wikipedia.org/wiki/WIMP)
* Текстовый и графический [оконный интерфейс](https://ru.wikipedia.org/wiki/%D0%9E%D0%BA%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
* Масштабируемый интерфейс пользователя [ZUI](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
* Руководство по разработки интерфейса пользователя [HIG](https://ru.wikipedia.org/wiki/HIG)
* [Веб-интерфейс](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
* [Веб-приложение](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)
* [Веб-программирование](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
* [Интерфейс](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
* [Категория:Интерфейсы](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B)
* [Голосовой интерфейс](https://ru.wikipedia.org/wiki/%D0%93%D0%BE%D0%BB%D0%BE%D1%81%D0%BE%D0%B2%D0%BE%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
* [Нейрокомпьютерный интерфейс](https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%B9%D1%80%D0%BE%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
* [Жестовый интерфейс](https://ru.wikipedia.org/wiki/%D0%96%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
* [Тактильный интерфейс](https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%BA%D1%82%D0%B8%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
* [Осязательный интерфейс пользователя](https://ru.wikipedia.org/wiki/%D0%9E%D1%81%D1%8F%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
* [Человеко-компьютерное взаимодействие](https://ru.wikipedia.org/wiki/%D0%A7%D0%B5%D0%BB%D0%BE%D0%B2%D0%B5%D0%BA%D0%BE-%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%BE%D0%B5_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5)
* [Проектирование взаимодействия](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F)
* "SPI Programming Manual" ; Part Number: 427506-007; Published: February 201

