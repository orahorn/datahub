# Тестирование

Тестирование бывает ручное и автоматическое, когда тестировщика заменяет машина либо другое ПО.


## Модульное тестирование

Есть парадигма "тестирования через разработку" (TDD - Test Driven Development): сначала пишется
заготовка теста, который задаёт входное значение тестируемому модулю, запускает его,
и сравнивает выданный результат.
Тесты идут отдельно, но должны покрывать максимально возможно все модули и все характерные
диаппазоны проверяемых значений.

## C

### gcov

Для классического Си в комплекте сборного компилятора GCC есть утилита
gcov, которая определяет при сеансе прогона тестов, насколько процентов
и какие части тестируемого кода покрыты или не покрыты тестами.

Например, напишем прототип-симулятор командного интерпретатора на классическом Си в файл `gcov1.c`:


```c
#include <stdio.h>

int main(){
        char command;
        do{
                scanf("%c", &command);
                switch(command) {
                case '\n':
                        break;
                case 'Q':
                        break;
                case 'A':
                        printf("command %c executed\n", command);
                        break;
                case 'B':
                        printf("command %c executed\n", command);
                        break;
                default:
                        printf("I did not recognize the command: %c\n", command);                       break;
                }
        } while( command != 'Q');

        return 0;
}
```

Он будет выполнять пару команд A и B, а по команде Q завершать свою работу.

Собираем программу со специальным флагом `--coverage`:

```
$ CFLAGS='--coverage' make gcov1
cc --coverage    gcov1.c   -o gcov1
```

Получаем дополнительный файл `gcov1.gcno` для отслеживания покрытия.
В-ручную создаём текстовый файл `gcov1.txt`, с как-бы введёнными командами:

```
A
A
A
A
Q

```

Т.е. введём 4 раза подряд команду A и для выхода - Q.

Теперь выполним тестовый прогон этого файла, подменив им стандартный ввод:

```
$ ./gcov1< gcov1.txt
command A executed
command A executed
command A executed
command A executed
```

После прогона, получаем второй доп. файл прогона `gcov1.gcda` .

Теперь посмотрим специальной утилитой процент покрытия строк исходного
кода тестами:

```
$ gcov gcov1
File 'gcov1.c'
Lines executed:70.59% of 17
Creating 'gcov1.c.gcov'
```

Как видим, 70,5% кода покрыто.
Посмотрим тот самый файл `gcov1.c.gcov`:

```
        -:    0:Source:gcov1.c
        -:    0:Graph:gcov1.gcno
        -:    0:Data:gcov1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:
        9:    3:int main(){
        -:    4:        char command;
        -:    5:        do{
        9:    6:                scanf("%c", &command);
        9:    7:                switch(command) {
        4:    8:                case '\n':
        4:    9:                        break;
        1:   10:                case 'Q':
        1:   11:                        break;
        4:   12:                case 'A':
        4:   13:                        printf("command %c executed\n", command);
        4:   14:                        break;
    #####:   15:                case 'B':
    #####:   16:                        printf("command %c executed\n", command);
    #####:   17:                        break;
    #####:   18:                default:
    #####:   19:                        printf("I did not recognize the command: %c\n", command);                       break;
        -:   20:                }
        9:   21:        } while( command != 'Q');
        -:   22:
        1:   23:        return 0;
        -:   24:}
        -:   25:
```

До двоеточия (`:`), указано число прогонов или прочерк (`-`), если код к этому не имеет отношение. Но если выработан
машинный код, который при прогоне не разу не исполнился, то строчки этого исходного кода будут промаркированы
решётками (`#####`). Из конкретного примера видно, что строки команды B ни разу в процессе прогона не исполнились.
Т.е. на это надо обратить внимание тестировщику-программисту...

Пакет lcov расширяет функционал gcov расширяя его отчёты. Устанавливается командой:

	sudo apt install lcov

После этого в текущем каталоге запускаем преобразование
исследования процесса покрытия в файл `coverage.info`, допустим:

```
$ lcov --capture --directory . --output=coverage.info
Capturing coverage data from .
Found gcov version: 7.5.0
Scanning . for .gcda files ...
Found 1 data files in .
Processing gcov1.gcda
Finished .info-file creation
```

Конвертируем info-файл в привычный HTML:


```
$ genhtml coverage.info --output-directory=res
Reading data file coverage.info
Found 1 entries.
Found common filename prefix "/home/dron/languages"
Writing .css and .png files.
Generating output.
Processing file C/gcov1.c
Writing directory view page.
Overall coverage rate:
  lines......: 70.6% (12 of 17 lines)
  functions..: 100.0% (1 of 1 function)
```

Здесь `/home/dron/languages` - это подкаталог в домашнем каталоге, в частности.
Перейдя в его подкаталог вывода `res` откроем в браузере там файл `index.html` и получим
красивый вывод о непроведённых местах тестирования (непокрытых тестами).



### Check

Пакет [check](http://check.sourceforge.net/) предназначен для модульного и 
раздельного тестирования кода на классическом Си: перехвата разных сигналов,
падений , исключений и т.д.
Есть интеграция с autoconf.



## C++

### UnitTest++

Тестирование приложений на С++ происходит на фреймворке
[unittest++](http://unittest-cpp.sourceforge.net/)
пакет работает как в Visual Studio, так и VS.NET 2002
и, конечно с GNU C++ (g++).

Технология тестирования состоит в том, что среди модулей проекта пришется готовый
исполнимый модуль, который вызывает различные проверки остальных модулей.
В этом тестирующем модуле подключается заголовочный файл `UnitTest++.h`
запускаются макросы `TEST` с условиями и выполняются
вложенные макросы проверок этого теста с именем `CHECK`:

```c++
#include <UnitTest++.h>

TEST(имя теста)
{
    CHECK(логическое_выражение);
}

int main()
{
       return UnitTest::RunAllTests();
}

```

Как видно библиотека `UnitTest++` находится в пространстве имён `UnitTest`
и всё тестирование запускается функцией `RunAllTests()`

Макросы тестирования можно включать и в остальные модули,
но это может усложнить рабочий код.

Среди прочих интересных макросов:

```c++
CHECK_EQUAL(значение_1, значение_2);
```

Сравнение вещественных чисел с плавающей запятой
на заданную точность:

```c++
CHECK_CLOSE(число1, число2, точность);
```

Сравнение целых и чисел с плавающей точкой:

```c++
CHECK_ARRAY_EQUAL(массив1, массив2, длина);
CHECK_ARRAY_CLOSE(массив3, массив4, длина, точность);
```

Также есть макрос тестирования исключений C++: `CHECK_THROW`...

### Google test

[gtest](http://code.google.com/p/googletest/) фреймворк Google для тестирования кода на C++
 есть в пакете libgtest-dev на Debin/Ubuntu.

Он основан на семействе тестов xUnit для разных языков программирования.
Есть интеграция с CMake.

Идеалогия разработки соответствует концепции модульного тестирования:
код разбивается на функции, хранящиеся в отдельных файлах-единицах трансляции.

Для каждого файла рабочего кода пишется с похожим именем (чтобы не путаться)
файл с тестами каждой функции. В тестирующем файле подключается заголовочный
файл и библиотека.
Прописываются макросы тестирования с ожиданием и результатом.


### CppUnit

Фреймворк [cppunit](http://cppunit.sourceforge.net/) создан по мотивам
и в идеологии xUnit and JUnit.
В Debian/Ubuntu располагается в пакетах:

* libcppunit
* libcppunit-dev

Пакет libqttestrunner1 обеспечивает для тестирования графическую среду на Qt.

Есть интеграция с GNU autoconf.

## C#

В составе пакета libnunit-cil-dev используется 
пакет модульного тестирования [nunit](http://www.nunit.org/) .


## Python3

Для тестирования кода на языке программирования Python
есть ряд тестирующих фремворков.

В пакете Debian/Ubuntu `python3-pytest` есть
средство тестирования Python3
[pytest](http://pytest.org/) .

## Erlang

Атоматизированное тестирование возможно с помощью пакета erlang-common-test.
Тестирование ведётся с помощью технологии чёрных (протоколы SNMP, Telnet, HTTP)
и белых (вызовы API Erlang) ящиков.

Для тестирования приложений не только на языке Erlang - есть отдельный
пакет erlang-test-server , который позволяет по сети запускать отдельный процесс,
которые может создавать HTML отчёты по тестированию.

Пакет erlang-eunit поддерживает модульное (unit) тестирование.


## Java

Пакет junit4 обеспечивает регрессионное тестирование кода на Java.

[TestNG](http://testng.org) - более новый тестовый пакет, чем JUnit и NUnit



## Источники

* [Автоматизированное тестирование](https://ru.wikipedia.org/wiki/Автоматизированное_тестирование)
* [Качество продукции](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%BF%D1%80%D0%BE%D0%B4%D1%83%D0%BA%D1%86%D0%B8%D0%B8)
* [Тестирование программного обеспечения](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)


