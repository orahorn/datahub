# Лабораторные занятия

Общие рекомендации к выполнению лабораторных работ: актуальный дистрибутив Linux (желательно Debian или Ubuntu).
Также возможно использование сборочных сред, таких как Visual Studio Code в Windows, cygwin. В macOS возможно
использование XCode и дистрибутивов свободных программ, таких как macports, fink и т.д.

## 01. Интерфейсы

[Лекция](01-interfaces.md)
 

### 01.01. Графический интерфейс

_Исходные данные_: установленная библиотека [FLTK](https://ru.wikipedia.org/wiki/FLTK)
и средства компиляции программ C++.

_Задание_: написать простейшую оконную программу с фиксированным заголовком.
Запустить и написать краткий отчет о процессе компиляции программы с разделяемой библиотекой.

_Дополнительный материал_: [утилита fltk-config](http://orahorn.neonarod.com/tui4gui/02-FLTK-config.html)

## 02. Языки программирования и двоичный код

[Лекция](02-code.md)

### 02.01. GNU Binutils

_Исходные данные_: [пакет двоичных утилит GNU](https://ru.wikipedia.org/wiki/GNU_Binutils) , любые двоичные файлы разных форматов
и библиотеки (разделяемые и статические).

_Задания_:

* посмотреть с помощью утилиты `ldd` с какими библиотеками скомпонован двоичный файл программы.
* с помощью утилиты `strings` просмотреть читаемые тексты ASCII внутри программ или других двоичных файлов
* Утилитой objdump посмотреть поля исполнимых программ, разделяемых библиотек или файлов с объектным кодом
* Использовать readelf для чтения исполнимого файла на Unix системе.

_Замечение_: для определения типа файла воспользоваться утилитой [file](https://ru.wikipedia.org/wiki/File_(Unix))

### 02.02. Язык C# и платформы .Net и Mono

_Исходные данные_: среда компиляции программ на языке C# и пакет программ для платформы .Net либо Mono

_Задание_: составить, скомпилировать  и запустить простейшую программу на C# вида:

* консольное приложение
* приложение с ГПИ Windows.Forms
* Web-приложение на основе библиотеки [XSP](https://en.wikipedia.org/wiki/XSP_(software))
* графическое приложение с использованием библиотеки [GtkSharp](https://www.mono-project.com/docs/gui/gtksharp/)
* дополнительно: поставить компилятор .Net/Mono Visual Basic, собрать простейшую консольную программу

### 02.03 Go-lang

_Исодные данные_: компилятор языка [Go](https://ru.wikipedia.org/wiki/Go),
либо web-среда [replit](https://replit.com/languages/go).

_Задание_: составить и скомпилировать простейшую консольную программу на Go. Запустить её. Посмотреть версии компилятора.
Разобраться в инфрастркутуре каталогов сборки проектов на Go (законспектировать). Посмотреть электронную справку компилятора
командной строки.

### 02.04 Язык программирования Rust и пакетный менеджер cargo

_Исходные данные_: компиляторя языка [Rust](https://ru.wikipedia.org/wiki/Rust_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) и [менджер пакетов](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%B0%D0%BC%D0%B8) cargo.

_Задание_: с помощью cargo сгенерировать проект-заготовку простейшей программы и посмотреть его структуру. Собрать пакет в
двоичный вид, запустить приложение.

## 03. Инструменты разработки кода

[Лекция](03-tools.md)

### 03.01. Сборочная утилита make

_Исходные данные_: [компилятор языка C](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B_%D0%A1%D0%B8)
, пакет Debian/Ubuntu [build-essential](https://packages.debian.org/oldoldstable/build-essential)
c утилитой [GNU make](https://www.gnu.org/software/make/)
или [аналогичная реализация](https://ru.wikipedia.org/wiki/Make)
(например, из [Cygwin](https://ru.wikipedia.org/wiki/Cygwin)).

_Задание_: написать в файл простейшую программу с вызовом функции из дополнительной не
[стандратной библиотеки](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0_%D0%A1%D0%B8),
например, [математики](https://ru.wikipedia.org/wiki/Math.h).

В утилите make:

* посмотреть предустановленные правила сборки
* собрать с помощью make и установки переменной окружения `LDLIBS` нужной бибилотеки вашу программу
* составить для сборки приложения текст `Makefile`, добавить туда в него цель `clean:`, которая сотрёт двоичную проагрмму


### 03.02. Кроссплатформенное средство сборки CMake

_Исходные данные_: [компилятор языка C++](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B_C%2B%2B) , средство [CMake](https://ru.wikipedia.org/wiki/CMake)
отедльно или в составе
[интегрированной среды разработки](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D1%80%D0%B5%D0%B4%D0%B0_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8).

_Задание_: написать
[заголовочный файл](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB)
с объявлением функции печати строки, и в отдельный файл с
[исходным текстом](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9_%D1%82%D0%B5%D0%BA%D1%81%D1%82)
внести определение этой функции. В третий файл записать вызов этой функции из точки входа в программу (функция main()).
Для сборки программы из этих исходных файлов записать  `CMakeLists.txt` с директивами сборки.

Утилитой CMake :

* посмотреть возможности сборки разных платформ (опция `-G`) и прокомментировать
* создать и запустить генерацию Makefile и сборку в отдельном каталоге
* попробовать выполняя подкоманды CMake (опция `-E`) - собирать в отдельном каталоге


## 04. Информационная безопасность

[лекция](04-security.md)

### 04.01. Беспарольная SSH аутентификация

_Исходные данные_:

* ПО [OpenSSH](https://ru.wikipedia.org/wiki/OpenSSH)
* [IP-адрес](https://ru.wikipedia.org/wiki/IP-%D0%B0%D0%B4%D1%80%D0%B5%D1%81) одного компьютера
* IP-адрес другого компьютера
* На обоих компьютерах заведена учётная запись с одним и тем же идентификатором имени пользователя: `user`

_Задание_:

Создать пару ключей OpenSSH для осуществления беспарольной идентификации.

_Замечание_:

Для выполнения задания рекомендуется использовать утилиты `ssh-keygen` и `ssh-copy-id` .

### 04.02. Шифрование текстового файла

_Исходные данные_: 

Для выполнения задания использовать пакет [GnuPG](https://ru.wikipedia.org/wiki/GnuPG)

_Задание_:

Создать текстовый файл с произвольным содержимым.
Зашифровать его  утилитой `gpg` с паролем, удалив исходный файл.
Расшифровать той же утилитой полученный файл, воспользовавшись знанием пароля.


## 05. Тестирование

[лекция](05-testing.md)

### 05.01. Проверка покрытия тестами утилитой gcov

_Исходные данные_:

[Компилятор GCC](https://ru.wikipedia.org/wiki/GNU_Compiler_Collection)


_Задание_:

* Написать на [C](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))
прототип-симулятор командного интерпретатора: команда одна буква и результат вывод этой буквы.
* Собрать его с помощью опции `--coverage` в исполняемый модуль и отсмотреть образовавшийся доп. файл для сбора данных о покрытии
* Создать текстовый файл с командами-буквами, последняя команда завершения нашей программы
* Запустить программу подставив на её стандартный ввод текстовый файл с коммандами и посмотреть ещё один файл с данными о прогоне
* С помощью утилиты `gcov` из `gcc` посмотреть статистику и части выполненного и не выполненного исходного кода.

## 06. Сети и телекоммуникации

[лекция](10-networks.md)

### 06.01. Сервер

_Исходные данные_:

* Реальные или виртуальные две машины со связанными адресами в одной подсети либо несколько сетевых адресов на одной машине (сложней)
* Утилита netcat

_Задание_:

* С помощью [socket API](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82%D1%8B_%D0%91%D0%B5%D1%80%D0%BA%D0%BB%D0%B8)
написать простейший сервер, который слушает локальный адрес на определённом порту. В коде должна быть отправка сообщения
клиенту.
* Утилитой [netcat](https://ru.wikipedia.org/wiki/Netcat) (рекомендуется OpenBSD реализация) сделать запрос с клиента по другому адресу на сервер по указанному порту и просмотреть полученное сообщение


### 06.02. Клиент

_Исходные данные_:

См. выше.

_Задание_:

* На "Беркли Сокетах" написать клиент, который отсылает текст на сервер и читает из сервера ответный текст.
* В качестве сервера использовать утилиту netcat.

### 06.03. Установки сетевых интерфейсов

_Исходные данные_:

Пакет [ethtool](https://en.wikipedia.org/wiki/Ethtool)

_Задание_:

* Посмотреть настройки сетевых интерфейсов (рабочие параметры) с помощью `ethtool` утилиты
* Попробовать поменять размеры передающего и принимающего буфера. Как изменилась на системе скорость сетевой передачи?

### 06.04. Трассировка сетевого потока

_Исходные данные_:

* пакет с утилитой [tcpdump](https://ru.wikipedia.org/wiki/Tcpdump)
* пакет c приложением [wireshark](https://ru.wikipedia.org/wiki/Wireshark)

_Задание_:

* с помощью опции `-i` посмотреть на заданном интерфейсе утилитой tcpdump трафик. 
* записать с помощью той же утилиты файл, а потом прочесть его и проанализировать
* попробовать поработать с фильтрами трафика `host`, `port` и т.д.
* посмотреть и проанализировать трафик в приложении wireshark, прочесть в ней файл с сетевым дампом

### 06.05. SNMP

_Исходные данные_:

пакет [Net-SNMP](https://ru.wikipedia.org/wiki/Net-SNMP)

_Задание_:

С помощью утилиты [snmpwalk](https://ru.wikipedia.org/wiki/Net-SNMP#Snmpwalk)
просмотреть на текущей или другой машине куст переменных системы


## 07. Производительность и распараллеливание

[лекция](20-parallelization.md)

### 07.01. Демонстрация ПО Open MPI

_Исходные данные_:

* [компилятор языка программирования C]()https://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F), а также дополнительно других (C++, Fortran, Java...)
* программное обеспечение [Open MPI](https://en.wikipedia.org/wiki/Open_MPI)

_Задание_:

Разработать программу с использованием библиотеки Open MPI,
которая в каждом своём параллельном экземпляре печатает его порядковый номер (rank).
Продемонстрировать печать порядковых номеров для размера пяти одновременных процессов на одном компьютере (узле).

### 07.02. Ветвление процесса

_Исходные данные_:

Компилятор языка C.

_Задание_:

Написать программу, в которой происходит ветвление текущего процесс функцией [fork()](https://ru.wikipedia.org/wiki/Fork).
Вывести сообщения в процессе-родителе и процессе-потомке.


### 07.03. Потоки процесса

_Исходные данные_:

Компилятор языка C.

_Задание_:

Написать программу с использованием библиотеки [POSIX Threads](https://ru.wikipedia.org/wiki/POSIX_Threads).
В функции-потокие печатать сообщение "b", в родительской функции (main()) печатать "a".

_Замечания_:

* Можно использовать компиляторы и интерпретаторы других языков, например C++ или Perl.
* В POSIX несовместимых системах, таких, как Windows, например, рекомендуется поставить ПО реализующее т.н. обёртки, вроде [Subsystem for UNIX-based Applications](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9_%D0%BD%D0%B0_%D0%B1%D0%B0%D0%B7%D0%B5_UNIX) (SUA).

## 08. Роль баз данных в ИУС

[Лекция](30-databases.md)

### 08.01. Oracle Berkeley Database

_Исходные данные_:

* Комплект ПО [Berkeley DB](https://ru.wikipedia.org/wiki/Berkeley_DB) с библиотеками и утилитами
* Интерпретаторы языков программирования:
	- [Python](https://ru.wikipedia.org/wiki/Python)
	- [Perl](https://ru.wikipedia.org/wiki/Perl)

_Задание_:

* создать текстовый файл в формате чередующихся строк ключ1, значение1, ключ2, значение2,...
* импортировать утилитой `db_load` этот текстовый файл в формат БД Berkeley
* утилитой `db_dump` проанализировать получившийся файл
* На Python написать простейший скрипт для прочтения этого файла, используя модуль [bsddb3](https://pypi.org/project/bsddb3/)
* С использованием Perl разработать скрипт, который с помощью [DB_File](https://perldoc.perl.org/DB_File) читает тот же DBM файл в хеш и распечатывает его на экране

### 08.02. GNU Database Manager

_Исходные данные_:

* ПО [GDBM](https://www.gnu.org.ua/software/gdbm/)
* Компилятор языка C

_Задание_


* На языке C с подключением библиотеки GDBM написать программу, которая создаёт файл отображения одних строк (ключей) в другие - значения
* Программой [file](https://ru.wikipedia.org/wiki/File_(Unix)) убедиться, что база данных создалась.
* На том же Си написать другую программу, которая будет читать и распечатывать данные из файла с данными.

### 08.02. СУБД SQLite

_Исходные данные_:

* Комплект ПО [SQLite-3](https://ru.wikipedia.org/wiki/SQLite), с утилитой командной строки (интерпретатор SQL-команд), библиотеки
* Компилятор C
* Интерпретаторы:
	- Perl
	- [TCL](https://ru.wikipedia.org/wiki/Tcl)

_Задание_:

* Написать скрипт, создающий простейшую БД с таблицей и заполняющий её набором в несколько строк
* Прочитать эту таблицу в утилите [sqlite3 CLI](https://www.sqlite.org/cli.html)
* На классическом C написать программу с [функцией обратного вызова](https://ru.wikipedia.org/wiki/Callback_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)), для чтения таблицы SQLite
* На [Perl DBI](https://dbi.perl.org/) [DBD::SQLite](https://metacpan.org/pod/DBD::SQLite) написать скрипт, читающий таблицу
* Сделать на TCL скрипт, который будет выполнять с произвольным SQLite файлом данных произвольные SQL-команды


### 08.03. Клиент-серверные реляционные СУБД MySQL/PostgreSQL

_Исходные данные_:

* Дистрибутивы ПО MySQL/PostgreSQL
* Два компьютера (удобней гостевые на виртуальных машинах)
 

_Задание_:

* Установить на одной машине сервер и клиент MySQL/PostgreSQL, на другой машине - только клиент
* Установить в качестве управляющего - дополнительное ПО:
	- [phpMyAdmin](https://ru.wikipedia.org/wiki/PhpMyAdmin)
	- [pgAdmin4](https://www.pgadmin.org/)
	- возможно другое ПО по вашему вкусу
* Настроить доступ на сервер БД
* Соединиться с базой в SQL -интерпретаторе и создать таблицы, заполнить их данными

### 08.04. СУБД больших данных NoSQL

_Исходные данные_:

* Узлы на базе выделеных компьютеров, либо виртуальные окружения
* Дистрибутивы ПО:
	- [MongoDB](https://ru.wikipedia.org/wiki/MongoDB)
	- [Redis](https://ru.wikipedia.org/wiki/Redis)

_Задание_:

* Развернуть дистрибутивы MongoDB и Redis
* Настроить доступы на узлы БД
* Заполнить узлы данными


## 09. Журналирование событий и ведение статистики работы ИУС

[Лекция](40-logstat.md) 

## 09.01. POSIX Syslog API

_Исходные данные_:

* [POSIX](https://ru.wikipedia.org/wiki/POSIX)-совместимая система, например, [Unix](https://ru.wikipedia.org/wiki/Unix)
* компилятор языка [C](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))


_Задание_:

* Включить мониторинг файла событий [syslog](https://ru.wikipedia.org/wiki/Syslog) утилитой [tail](https://ru.wikipedia.org/wiki/Tail)
* Утилитой [logger](https://ru.wikipedia.org/wiki/Logger) послать сообщение и убедиться, что tail его отобразил
* Дополнительно: включить в настройках передачу сообщения на другой компьютер в сети.
	- проверить утилитой [tcpdump](https://ru.wikipedia.org/wiki/Tcpdump) на [порту](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%82_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B5_%D1%81%D0%B5%D1%82%D0%B8)) 514
* разработать программу на C, которая посылает syslog-сообщение. Убедиться, что оно также достигает назначения.


### 09.02.  SystemD Journal

_Исходные данные_:

См. выше.

_Задание_:

* В утилите [journalctl](https://www.freedesktop.org/software/systemd/man/journalctl.html) отфильтровать сообщения с помощью выражений:
	- критические
	- непрерывно выводящиеся информационные
	- со вчерашнего дня
* С помощью [SystemD Journal API](https://www.freedesktop.org/software/systemd/man/sd-journal.html) напечатать в журнал сообщение и прочесть его утилитой journalctl.


